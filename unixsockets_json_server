package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net"
	"os"
)

const SockAddr = "/tmp/echo.sock"

type sockOut struct {
	KeyCheckSum   uint32 `json:"KeyCheckSum"`
	ValueCheckSum uint32 `json:"ValueCheckSum"`
	Name          string `json:"name"`
}

type sockIn struct {
	Name string `json:"name"`
}

func echoServer(c net.Conn) {
	defer c.Close()
	decode := json.NewDecoder(c)
	encode := json.NewEncoder(c)

	var inputJSON sockIn
	err := decode.Decode(&inputJSON)
	if err != nil {
		fmt.Printf("Error is %v", err)
	}
	fmt.Printf("Name: %s\n", inputJSON.Name)

	outputJSON := sockOut{
		KeyCheckSum:   10,
		ValueCheckSum: 10,
		Name:          inputJSON.Name,
	}
	// Send response back to the socket request
	err = encode.Encode(outputJSON)
	if err != nil {
		fmt.Printf("Error is %v", err)
	}
}

func main() {
	// When servers shut down, the file representing the socket can remain in the file system unless the server
	// did orderly cleanup after itself. If we re-run another server with the same socket path, we may get an error
	// To prevent that, the server begins by removing the socket file, if it exists.
	if err := os.RemoveAll(SockAddr); err != nil {
		log.Fatal(err)
	}

	l, err := net.Listen("unix", SockAddr)
	if err != nil {
		log.Fatal("listen error:", err)
	}
	defer l.Close()

	for {
		// Accept new connections, dispatching them to echoServer
		// in a goroutine.
		conn, err := l.Accept()
		if err != nil {
			log.Panic("accept error:", err)
		}
		go echoServer(conn)
	}
}
